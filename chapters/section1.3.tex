\section{数据处理与应用}\index{数据处理与应用}

\begin{enumerate}
%% ============= 1
\item 答案：D。考查数据整理方法与目的。

%% ============= 2
\item 答案：C。
	\begin{enumerate}[label=\Alph*.]
	\item 实验误差是测量值和真实值之间的偏差，不是虚假信息。
	\item 正确。
	\item 同一个信息对于不同的人价值可能不一样。
	\item 信息是信号、消息中所包含的含义，必须依附与数字、文字、图形、图像等载体。
	\end{enumerate}

%% ============= 3
\item 答案：B。
	\begin{enumerate}[label=\Alph*.]
	\item 互联网上只有已数字化的信息，没有数字化当然查不到。
	\item 知识的获得是人利用自身已有的知识对信息进行加工，进而将新的信息纳入自己的知识结构的过程。检索到也只是看到，并不一定已内化成自己的知识。
	\item 天才也要记单词啊。
	\item 正确。
	\end{enumerate}

%% ============= 4
\item 答案：B。考查pandas数据处理drop()函数、groupby()函数功能的理解。注释如下：
\begin{lstlisting}[numbers=left]
import pandas as pd									# 导入并使用pd作为别名
df = pd.read_csv("mnxk.csv", sep=",")				# 读取数据
df1 = df.drop("已选科目数", axis=1)				    # 删除“已选科目数”列
print(df.head())									# 打印df的前5行
print(df1.head())									# 打印df1的前5行
sc=df1.groupby("班级", as_index=False).count()	    # 按“班级”分组
m = len(df)											# df的行数
n = len(df1)										# df1的行数
print(sc)											# 分组后的数据
\end{lstlisting}
注意pandas的很多操作处理后原始数据都不会改变。比如，第3行drop()函数删除了“已选科目数”列，参数“axis=1”指明了这是列而不是行。该函数调用后，产生了一个新的数据集合并赋值给对象df1，而原始的数据集合df未曾变化。选项B就考查了pandas数据处理的这个特点：第4行打印的结果是原始数据的前5行，包含“已选科目数”这列数据，而第5行的输出的5行数据虽然大部分与前面相同，但不含“已选科目数”这列数据。选项C考查的是df和df1数据对象的行数是否相同，由于没有删除行，行数必然是一样的。选项D，第6行的分组可以让相同班级的数据合并成一行数据，这个数据的每列数据是原先该列数据的非空单元格个个数（即count()函数的功能）。如，若原始数据如左侧所示，则执行第6行分组语句后的结果如右侧所示。在右侧数据中，“1班”的“Name”值是4，表示原始数据中1班“Name”列数据非空单元格个有4个；“1班”的“物理”值是2，表示原始数据中1班“物理”列数据非空单元格个有2个（相当于1班有两个2人选了物理）。
\begin{lstlisting}
   班级 Name  物理 历史 技术 化学          班级 Name 物理 历史 技术 化学
0  1班  张三丰   1   1   1                0  1班  4   2   1   2   2
1  2班   郭靖    1       1                1  2班  2   1   0   1   0
2  1班  小龙女   1           1            2  3班  2   2   1   1   2
3  2班  李秋水                
4  3班   杨过    1       1   1
5  1班  令狐冲                
6  3班  任我行   1   1       1
7  1班   黄蓉            1   1
\end{lstlisting}

%% ============= 5
\item 答案：D。
	\begin{enumerate}[label=\Alph*.]
	\item 若化成十进制计算：$10H=16D, 10B = 2D, 16D+2D=18D$。
	\item $1AH + 2AH = 44H$，注意十六进制下$A + A$等于$14$。
	\item 正确。
	\item 若化成十六进制计算：$10D + 10B = AH + 2H = CH$，即十六进制的值是$C$。
	\end{enumerate}

%% ============= 6
\item 答案：B。
	\begin{enumerate}[label=\Alph*.]
	\item 。
	\item 。
	\item 。
	\item 。
	\end{enumerate}

%% ============= 7
\item 答案：B。
	\begin{enumerate}[label=\Alph*.]
	\item 。
	\item 。
	\item 。
	\item 。
	\end{enumerate}

%% ============= 8
\item 答案：D。
	\begin{enumerate}[label=\Alph*.]
	\item 。
	\item 。
	\item 。
	\item 。
	\end{enumerate}

%% ============= 9
\item 答案：C。
	\begin{enumerate}[label=\Alph*.]
	\item 。
	\item 。
	\item 。
	\item 。
	\end{enumerate}

%% ============= 10
\item 考查pandas数据处理与应用。
	\begin{enumerate}[label=$(\arabic*)$]
	\item 考查数据处理的实际用途，帮助理解题目情景。
	\item 考查pandas数据格式的识别。
\setcounter{qnumber}{1}
\begin{lstlisting}[numbers=left]
def s_review(c):    
    for r in range(df.shape[0]):            # 批阅1个单选题
        if df.at[r, qnum[c]] == `\clozeblank{2}`:
            tmp = 3
            df.at[r, score[c-2]] = tmp
            df.at[r, score[10]] += tmp      # 计算总分，存入"sum"列
qnum = df.columns
sans = "BDCABDDBCB"                         # 本次作业的标准答案
score=["sc1","sc2","sc3","sc4","sc5","sc6","sc7","sc8","sc9","sc10","sum"]
for c in score:
    df[c] = 0
for c in range(2,12):                       # 逐题批阅
    `\clozeblank{2}`
print(df)
df.to_excel("客观题成绩.xlsx", index=False)  # 保存结果
\end{lstlisting}
	\item 解题过程：
		\begin{enumerate}[label=$(\alph*)$]
		\item 从第7行主程序开始阅读，对pandas程序阅读，一定要直到变量保存的数据是什么？数据的结构是怎样的？
		\item 第7行qnum保存了数据对象df的所有列名称，即\lstinline|["name", "snum", "ans1", "ans2", ..., "ans10"]|。第10行的循环，结合第9行score列表中的数据可以知道第11行在数据对象df中新增了很多数据列，列名称分别是“sc1”、“sc2”、“sc3”、……、“sum”，每列的值都是0。这也是pandas的特点，数据列直接可以参与算术运算、关系运算和赋值操作，每种操作都可以将该列的所有行都进行相应处理。
		\item 第②空处所进行的循环是逐题批阅。原始表格数据中一题就是一列数据，列序号是$2 \sim 12$，刚好能对上这里的循环范围。因此，第12行的循环变量$c$相当于列序号——不过，pandas需要的是列名称，这就需要qnum中对应的列名称来引用原始数据了。这里需要调用第一行的s\_review()函数。
		\item 阅读s\_review()函数。第2行df.shape可以返回数据对象df的维度“形状”：行数（df.shape[0]）和列数（df.shape[1]），因此$r$就是行索引号。由\lstinline|df.at[r, qnum[c]]|操作可知qnum[c]必然是列名称，结合前面的分析可以知道$c$必然是列序号。由于列表qnum中索引$2$号的列名称才是第一题名称“ans1”，因此$c$期望的值也应该从$2$开始。那么第②空的函数调用就好办了：函数名已知的，参数作用也推知了，所以答案应该是\lstinline|s_revieww(c)|，就让$c$的值从2开始传递、调用函数。另外从s\_review()函数的结构上看，它有return语句返回值，所以这空也无需考虑赋值——直接调用即可。
		\item 再回到第3行程序，\lstinline|df.at[r, qnum[c]]|取得了$c$列每个人填写的答案，它们需要与标准答案做比较，标准答案保存再sans字符串中，它的索引号是从0开始的，所以第①空的答案是\lstinline|sans[c-2]|。
		\item 第5行的程序是将该行（第$r$行）对应的得分列赋值为tmp分分值（如“ans1”列对应的分值是“sc1”列）。第6行的程序是将该分值累加到它的总分中去（即“sum”列，它的值是10个选择题的得分累加而来）。
		\end{enumerate}
	\end{enumerate}


%% ============= 11
\item 考查文本数据处理、分词、字符串统计与字典的应用。
	\begin{enumerate}[label=$(\arabic*)$]
\setcounter{qnumber}{1}
\begin{lstlisting}[numbers=left]
import jieba                                     # 导入jieba模块
import pandas as pd
text = open("news.txt", encoding="utf-8").read() # 打开文本文件
words = jieba.lcut(text, cut_all=False)          # 分词
counts = {}
for name in words:
    if len(name) != 1 and not ("a" < name[0] < "z") and not ("0" < name[0] < "9"):
        if name in counts:
            counts[name] += 1                    # 词语已出现过
        else:
            counts[name] = 1                     # 词语第一次出现
# 字典转化为DataFrame格式存储
df = pd.DataFrame(list(counts.items()), columns=["词", "次数"])
df = df.sort_values("次数", ascending=False)     # 按“次数”降序排序
print(df)
\end{lstlisting}
	\item jieba是目前常用的分词模块，它是一个基于词典分词的模块。模块导入后，程序再第3行通过python的内置open()函数打开了文本文件，read()函数可以读取文件中的所有数据。第4行调用了jieba的lcut()函数进行分词，函数名中的“l”表示分词结果数据是一个列表（即list，这里了解即可，无需记忆），函数的cut\_all参数设定为False表示是精准分词，不会分隔“词中词”，当该参数设定为True时表示全模式分词，会分隔所有词。如“中华人民共和国”，False模式下结果是一个词\lstinline|["中华人民共和国"]|，True模式下会有多个词\lstinline|["中华", "人民", "共和国", "中华人民共和国"]|。对于words列表中的每个词，第7行程序过滤掉了单字、字母开头的、数字开头的字符串，因此答案选C。
	\item 本小题考查jieba分词的规则特点，因为它是用现有的词典进行分词的，因此想要添加一个新词时，只需在分词前添加该词再进行分词即可。具体可以通过\lstinline|jieba.add_word( "公益活动")|来添加该词。
	\item 第8行程序先判定某个单词name是否在字典counts的键名中出现过，如果出现过，则直接根据该键名取出其键值，然后加1后仍然存放在该键名上。else分支就是该键名第一次出现，因此该键值初始为1，答案是\lstinline|counts[name] = 1|。
	\end{enumerate}


%% ============= 12
\item 考查文本数据处理、分词、字符串统计与字典的应用。
	\begin{enumerate}[label=$(\arabic*)$]
\setcounter{qnumber}{1}
\begin{lstlisting}[numbers=left]

\end{lstlisting}
	\item 
	\end{enumerate}











\end{enumerate}


\newpage
