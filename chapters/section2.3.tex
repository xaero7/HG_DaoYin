\section{信息系统安全}\index{信息系统安全}

\begin{enumerate}
%% ============= 1
\item 答案：B。

%% ============= 2
\item 答案：C。

%% ============= 3
\item 答案：D。选项A：该系统主要还是用户名+口令认证技术，验证码也是一种动态口令认证技术。选项B：扫码登录相当于将某系统已登录的信息授权给另一个系统使用，也是身份认证。选项C：USB Key认证需要由USB硬件设备。

%% ============= 4
\item 答案：D。

%% ============= 5
\item 答案：B。

%% ============= 6
\item 答案：C。

%% ============= 7
\item 答案：B。

%% ============= 8
\item 答案：D。

%% ============= 9
\item 答案：C。访问控制的基本功能是保证合法用户访问授权的系统资料

%% ============= 10
\item 答案：A。

%% ============= 11
\item 考查python加密算法的实现：
	\begin{enumerate}[label=$(\arabic*)$]
	\item 数字要循环前移3位，因此$2 \to 9, 0 \to 7$；字母要后移3位，$F \to I, i \to l$。
\setcounter{qnumber}{1}
\begin{lstlisting}[numbers=left]
def encrypt(ch, key):
    if ch >= 'a':
        ch2 = `\clozeblank{2}`
    else:
        ch2 = chr((ord(ch) - 65 + key) % 26 + 65)
    return ch2
code = input("请输入需要加密的明文：")
k = int(input("请输入密钥："))
micode = ""
for ch in code:
    if '0' <= ch <= '9':
        ch = str((int(ch) - k) % 10)
        ch2 = ch
    elif ('a' <= ch <= 'z') or ('A' <= ch <= 'Z'):
        ch2 = `\clozeblank{2}`
    else:
        ch2 = ch   # 其他字符不变
    micode += ch2
print("加密后的密文为：", micode)
\end{lstlisting}
	\item 阅读程序时，可以将变量的具体值代入后研究语句的功能。
		\begin{enumerate}[label=$(\alph*)$]
		\item 如在encrypt()函数中，第5行语句，ord(ch)是求字符的ASCII码，65是“A”的ASCII码值，代入ch的值是“A”时，表达式ord(ch)-65的结果是0，带入ch的值是“B”时，表达式ord(ch)-65的结果是1……相当于26个大写字母表中的序号。加上key的值，再“\% 26”的作用容易想到是往后移key个位置，并且超过26后相当于移到字母表的前面去。如“Z”在字母表中是25，后移3位，变成28，相当于字母表中的2号，即字母“C”。在大写字母表中的位置确定后，该表达式又加65后取chr()函数的值，相当于又重新映射到ASCII码表中的$65~90$号上，即“A”至“Z”。于是第①空是对小写字母作同样处理，答案是\lstinline|chr((ord(ch) - 97 + key) % 26 + 97)|。
		\item 第10行程序用变量ch遍历了code中的每个字符，也就是对原始输入的每个字符都要加密处理。
		\item 第12行程序对数字字符进行前移$k$位操作。那么第15行程序就是对字母的加密——后移操作。由之前的推断，encrypt()函数的第一个参数ch是待移动（待加密）的字符，key是移动的位数。因此这里调用的格式是\lstinline|encrypt(ch, k)|。由第18行程序知，加密结果应该存入变量ch2中，因此这里要将函数值赋给变量ch2。
		\item 第③空直接输出加密结果micode即可。
		\end{enumerate}	
	\end{enumerate}


\end{enumerate}


\newpage
